## npm의 문제점과 한계

### 유령 의존성

- 평탄화를 통해 공통 패키지를 상위로 올려서 설치하면 디스크 공간을 줄이고 불필요한 의존성을 제거하는 목표는 달성
- But 설치하지 않은 B 패키지에 대해서 개발자가 사용가능한 상황이 생김 → 유령의존성

![image.png](attachment:80f1aea5-6b93-48fd-9f96-c0f07d2bb2c9:image.png)

- 의존성 실종사고 : 내가 간접적으로 들고있던 B 패키지를 A,C 패키지에서 업데이트때 삭제해버리면 내 코드는 아무 잘못도 안했는데 터짐
- npm에서 운좋게 들어갔다 쳐도 평탄화를 허용하지 않는 pnpm으로 바꿔버리면 에러
- 해결방법은 코드에서 직접 쓰는 패키지는 package.json에 꼭 명시

### 디스크부하

- Node.js가 패키지를 찾는 **탐색 방식**이 시스템 성능(디스크 I/O)에 주는 부담
- 패키지를 한 번에 찾지 못할 경우, 예시 코드에 나온 것처럼 수많은 경로를 전부 확인해야 하므로 반복적인 파일 시스템 접근(I/O 호출)이 발생하여 부하를 줍니다.

### 너무 거대한 node_modules

- **공간 낭비:** 로컬 환경은 물론 CI/CD 및 배포 환경에서도 불필요한 비용과 공간을 소모
- **빌드 시간 증가:** 용량이 클수록 설치와 빌드 시간이 길어져 개발자의 생산성을 떨어뜨림
- **명령어 성능 저하:** `npm install` 실행 시 내부적으로 유효성을 검사하는 함수(`loadActual`, `reify` 등)의 성능이 현저히 떨어짐

### 변경에 취약한 lock file

프로젝트 규모가 커질수록 락 파일이 개발자의 통제를 벗어나는 현상을 지적

- **가독성 저하:** 락 파일 크기가 수 MB에 달하면 깃에서도 diff 확인 기능을 비활성화함.
- **결과:** 개발자는 `node_modules` 내부에서 정확히 어떤 일이 벌어지는지 세밀하게 통제하기 어려워지며, 이는 의존성을 안전하게 재현하려는 본래 목적을 무색하게 만들어버림.

## yarn

### yarn의 탄생

- **명칭과 유래:** 'yet another resource negotiator'의 약자로, 초기에는 고양이를 마스코트로 한 'kittens package manager(kpm)'로 기획
- **등장 배경:** 당시 npm(v3.x)이 가진 고질적인 문제였던 **'비결정성(Non-Determinism)'**을 해결하기 위해 페이스북에서 개발

### 당시 npm의 한계점 (yarn이 해결하고자 한 것)

- **의존성 트리의 불일치:** 설치 순서에 따라 `node_modules` 구조가 달라져, 개발자마다 혹은 서버 환경마다 서로 다른 결과가 발생하는 문제가 있었음
- **불안정한 버전 고정:** 당시 npm에도 `shrinkwrap.json`이 있었으나 수동으로 생성해야 했고 관리가 어려워 누락되기 일쑤
- **성능 및 네트워크 문제:** 오프라인 환경에서 설치가 불가능했으며, 패키지 무결성 검사가 SHA-1 해시 방식에 그쳐 보안 위험이 존재

### yarn의 혁신과 초기 성과

- **속도와 효율성: 병렬 설치 및 캐싱 기능을 통해** npm보다 압도적으로 빠른 속도를 보여줌
- **보안 및 신뢰성:** 체크섬(Checksum)을 통한 무결성 확인 절차를 강화하고, **오프라인 설치 기능**을 도입함
- **반응:** 출시 직후 깃허브 스타 수가 npm을 추월할 정도로 개발자 커뮤니티에서 빠르게 채택.

### yarn 2.0 등장과 논란

- pnp 모드를 기본적으로 활성화 시켜서 모든 node_modules를 zip으로 압축시킴
- node는 zip을 직접 읽을 수 없으므로 yarn node와 같은 명령어를 사용했어야함
- 초기에는 Flow나 React-Native 같은 대형 패키지들이 `node_modules`를 직접 참조했기 때문에 PnP 환경에서 사용할 수 없었음

## yarn berry

- `yarn.lock`은 사람이 읽고 리뷰하기 좋은 독자적 포맷을 쓰다가, Berry에서는 표준 YAML 형식을 채택
- 속도 최적화를 위해 npm 레지스트리를 직접 호출하는 대신 자체적인 프록시를 사용
- **PnP(Plug'n'Play):** 거대한 `node_modules` 대신 패키지를 압축된 **zip 파일**로 관리하여 용량과 탐색 시간을 획기적으로 줄임.

### PnP(Plug n Play)

![image.png](attachment:89473e6c-9d45-4187-a8e8-671691b5d3cd:image.png)

```jsx
const react = require("react");
console.log(react.version);
```

이 명령어를 node index.js로 하면 모듈을 찾을 수 없다는 에러가 발생한다.

그런데 `yarn run start` 로 실행하면 정상적으로 실행이된다.

yarn start는 node index.js와 다를게 없는데 왜 node_modules가 없는 상황에서 패키지를 제대로 찾지 못하는건가?

```jsx
node -r ./pnp.cjs index.js
```

- 이렇게 실행하면 yarn start와 동일하게 동작한다.
- -r은 require의 줄임말로 특정 프로그램을 실행하기 전 어떠한 모듈을 사전에 로드하도록 지시하는 역할
- **`pnp.cjs`의 역할:** `node_modules`가 없는 환경에서 Node.js가 패키지 위치를 알 수 있도록 맵(Map) 역할을 하는 실행 파일.

### Zero install (오프라인 설치)

- zero install을 설정하려면 `.yarnrc.yml` 파일을 생성하고 `enableGlobalCache: false` 설정을 추가한뒤 yarn으로 설치 진행

![image.png](attachment:81df805e-1442-4ed7-98bf-0b032b1e8f90:image.png)

- 글로벌 캐시에 있던 압축 파일이 해당 프로젝트의 `.yarn/cache` 폴더에 저장된 것을 확인가능
- 이 방식의 장점
  - 폐쇄적인 환겅에서 사용 가능: 인터넷 연결이 불가능한 환경이나 레지스트리에 접근할 수 없는 환경에서도 설치가 가능
  - 향상된 가독성: pacakge-lock.json은 크기가 커서 변경사항을 파악하기 어려운 경우가 많은데 YAML로 저장되어있으니 더 읽기 쉽게 작성됨.
  - 빠른 설치 속도: git 등의 버전 관리 시스템을 통한 설치가 원격 레지스트리를 방문하는것 보다 빠름
  - 각 버전별 환경을 쉽게 재현 가능: 오프라인 설치가 적용돼 있으면 버전을 변경할 때마다 의존성을 다시 설치할 필요 없이 해당 환경을 재현할 수 있음

### 플러그인 시스템

- **의존성 버전 결정 방식 변경**: `^`와 같은 의존성 버전 문법을 수정하여 특정 패키지가 설치되는 정확한 버전을 임의로 변경할 수 있습니다.
- **패키지 fetcher**: 패키지 데이터를 얻는 방식을 결정합니다. 예를 들어 npm 레지스트리뿐만 아니라 디스크 내부 등 다른 데이터 소스에서 직접 패키지를 가져올 수 있습니다.
- **새로운 명령어 추가**: Yarn에 새로운 명령어를 추가하여 Yarn API를 사용하거나 완전히 새로운 동작을 수행하게 할 수 있습니다.
- **새로운 이벤트 등록**: Yarn의 생명주기(Lifecycle) 동안 특별한 로직을 추가하여 실행할 수 있습니다.

### Yarn Berry 대표 플러그인

- **`yarn-plugin-outdated`**: Yarn Berry에서 사라진 `outdated` 명령어를 다시 사용할 수 있게 해줍니다. 이를 통해 업데이트가 필요한 패키지들을 쉽게 찾을 수 있습니다.
- **`yarn-plugin-engines`**: 패키지 실행에 필요한 Node.js 버전을 점검하는 기능입니다. 이 역시 Berry에서 기본적으로 제외되었으나 플러그인으로 다시 사용할 수 있습니다.
- **`yarn-plugin-licenses`**: 프로젝트가 의존하고 있는 모든 패키지의 라이선스 현황을 한눈에 확인할 수 있는 명령어를 제공합니다.
- **`yarn-plugin-nolyfill`**: `nolyfill`을 자동으로 실행하여 프로젝트 구조를 최적화하는 플러그인입니다.

## 3.3 pnpm: 디스크 공간 절약과 설치 속도의 혁신을 가져온 패키지 관리자

- 헝가리 출신의 개발자 졸탄 코잔이 2016년 첫 커밋을 시작으로 개발해온 프로젝트

### 글로벌 스토어의 하드링크

- pnpm은 각 패키지가 설치하는 하위 의존성을 node_modules가 아닌 기본적으로 ~/.pnpm이라고 하는 글로벌 스토에 저장한다.

![image.png](attachment:d2b2cd07-544d-4533-9db0-b41a6cbeb693:image.png)

![image.png](attachment:85232b6c-0b91-420e-8826-184f5ec202f0:image.png)

- react 패키지를 보면 .pnpm/react@18.81/node_modules/react 경로로 링크가 되어있다.
- 이는 react 폴더의 실제원본이 해당 경로에 있음을 보여준다.
- 다음으론 .pnpm 폴더인데 기존 npm,yarn에서 볼 수 있었던 react와 그 의존성 모듈들이 들어있음
  - 원본은 최상단에만 설치되고, 다른 참조들은 모두 링크로 연결되어있다.
- 이처럼 pnpm은 필요한 의존성들을 하드 링크라는 방식으로 연결해서 사용한다. 하드 링크는 파일 시스템의 기능 중 하나로, 동일한 데이터를 가리키는 여러 개의 파일 경로를 만드는 방식이다.
- 이렇게 하면 장점은
  - **디스크 공간 절약:** 같은 버전의 패키지를 100군데에서 쓰더라도 실제 파일은 `.pnpm` 폴더에 하나만 존재하므로 용량을 거의 차지하지 않음
  - 성능 향상: 파일을 복사하거나 상위 폴더를 계속 뒤저가면서 node_modules를 찾는 대신, **하드 링크를 사용해 빠르게 원하는 패키지를 찾을 수 있음**
  - **유령 의존성 방지:** 각 패키지는 자신이 직접 의존하는 패키지만 링크로 연결해서 볼 수 있기 때문에, 설치하지 않은 패키지에 몰래 접근하는 '유령 의존성' 문제를 구조적으로 차단

하드 링크 vs 심볼릭 링크

| **구분**      | **심볼릭 링크 (Symbolic Link)**                                            | **하드 링크 (Hard Link)**                                        |
| ------------- | -------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| **개념**      | 원본 파일의 경로(주소)를 가리키는 별도의 파일 (윈도우의 '바로가기'와 유사) | 원본 파일의 **데이터 블록(inode)**을 직접 가리키는 또 다른 이름  |
| **파일 구조** | 원본과 별개의 존재 (원본 삭제 시 링크 깨짐)                                | 원본과 **완전 동일한 데이터** 공유 (원본 삭제해도 링크는 유지됨) |
| **용량**      | 매우 작음 (경로 텍스트 정보만 저장)                                        | 원본과 동일하게 표시되나, **실제 디스크 공간은 추가 점유 안 함** |
| **디렉터리**  | 디렉터리(폴더) 연결 가능                                                   | 일반적으로 파일에만 가능 (디렉터리 불가)                         |
| **pnpm 활용** | `node_modules` 내부에 패키지 구조를 만들 때 사용 (`->` 표시)               | 글로벌 저장소(`.pnpm`)의 실제 파일을 프로젝트에 연결할 때 사용   |

### 평탄화 되지 않은 node_modules

- pnpm은 평탄화된 node_modules 구조를 피하기 위해서
  - 프로젝트의 ./node_modules에는 선언된 dependencies와 같은 직접 의존성만 위치 시킴
  - 이 패키지들의 실제 파일은 .pnpm에 하드링크로 연결 되어있음.

![image.png](attachment:ca01b05b-19c6-4859-b986-7e5a39b4682c:image.png)

### 콘텐츠 어드레서블 스토리지

- pnpm은 의존성을 콘텐츠 어드레서블 스토리지에 저장
- 파일이나 데이터 블록을 고유한 해시값으로 식별해서 저장하는 시스템

어떻게 작동할까?

기존의 npm은 프로젝트마다 필요한 패키지를 통째로 복사해서 `node_modules`에 넣습니다. 반면 pnpm은 다음과 같은 과정을 거칩니다.

1. **해시 생성:** 패키지 내부의 각 파일 내용에 대해 고유한 해시값(ID)을 생성합니다.
2. **전역 저장소 저장:** 생성된 해시값을 이름으로 하여 파일을 PC 내의 **단 한 곳(Global Store)**에 저장합니다. (보통 `~/.pnpm-store` 위치)
3. **하드 링크(Hard Link) 연결:** 실제 프로젝트의 `node_modules`에는 파일을 복사하는 대신, 전역 저장소에 있는 파일을 가리키는 **하드 링크**를 생성합니다.

→ 그렇게 때문에 압도적인 설치속도로 패키지를 설치할 수 있음

![image.png](attachment:c3917cfa-5345-4184-a90d-dc39c2181f5f:image.png)

Copy on Write는 데이터 복사를 최적화하는 기술로, 데이터의 복사본을 생성할 때 원본 데이터를 그대로 참조하고 실제 복사를 수행하지 않다가 원본 데이터가 변경될 때 새로운 복사본을 생성하는 방식

→ 일단 같이 쓰고 변경이 필요하면 복사해서 수정해라.

### pnpm의 PnP 지원

- npmrc 파일에 아래와 같이 추가하면 된다.

```jsx
node-linker=pnp // 패키지를 설치할 때 사용할 링커 정의
symlink=false
```

## npm, yarn, pnpm 비교

### 워크스페이스

### 1. 모노레포 (Monorepo)

모노레포는 "여러 개의 프로젝트를 하나의 소스 코드 저장소(Repository)에서 관리하는 소프트웨어 개발 전략"을 의미합니다.

- **범위:** 거시적인 아키텍처 개념.
- **특징:** 서로 다른 서비스(예: 웹 클라이언트, 서버, 공용 UI 라이브러리)를 단일 Git 레포지토리 안에 넣고 관리합니다.
- **목적:** 프로젝트 간 코드 공유의 용이성, 의존성 관리의 일원화, 일관된 CI/CD 파이프라인 구축.

### 2. 워크스페이스 (Workspace)

워크스페이스는 "패키지 매니저(npm, yarn, pnpm 등)가 하나의 레포지토리 내의 여러 패키지를 인식하고 관리할 수 있도록 지원하는 기능"입니다.

- **범위:** 미시적인 도구적 기능.
- **특징:** 각 프로젝트(패키지)의 `package.json`을 연결하여, 공통된 라이브러리를 중복 설치하지 않고 효율적으로 관리하게 해줍니다.
- **목적:** 로컬 패키지 간의 참조(Symlink) 자동화, 의존성 설치 최적화.

---
