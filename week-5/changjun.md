## 5-1. 트랜스파일링을 도와주는 도구 바벨

### 바벨의 필요성

왜 트랜스파일링이 필요할까?

2015년 ES6가 발표되면서 자바스크립트에는 많은 새로운 기능과 문법이 도입됐다. 그렇지만 최신기능을 IE나 사파리9 같은 구형 웹브라우저에서는 지원하지 않는점이 문제였다.

ES6 문법을 구형 브라우저 환경에서 동작하도록 코드를 변환해주는게 필요했다.

### **바벨의 등장**

바벨이 등장하기 전 구글에서 개발한 Traceur나 es-shim등이 트랜스파일러로 사용됨

세바스찬 맥켄지라는 사람이 바벨을 개발했고 이때 6to5라는 이름으로 사용함

근데 이름이 ES6에만 관련된 것으로 암시된다고 생각되어 프로젝트 이름을 바벨로 변경

### 바벨의 특징

**플러그인 시스템**

기본적으로 플러그인을 통해 유연한 확장성을 제공한다.

필요한 플러그인만 설치해서 선택적으로 트랜스파일링 할 수 있게 도와주고 → 이로 인해 개발자가 바벨에 직접 기여할 수 있는 생태계 마련도 한셈

**광범위한 자바스크립트 문법 지원**

바벨은 ECMAScript 기능 뿐만 아니라 ESNext, JSX, 타입스크립트 등 다양한 언어 확장 기능도 지원한다.

**지금도 리액트에선 바벨이 필수일까?**

바벨은 상대적으로 느릴 수 있고 설정이 복잡할 수 있다. 반면 요즘 vite나 esbuild같은 도구들을 통해 빌드 속도를 향상시키는 것을 목표로함 → 이것들은 JS 코드를 빠르게 번들링하고 필요한 경우 다시 전체 번들을 컴파일 하지 않고 즉각 업데이트해서 개발 시간을 단축시키는데 도움을 준다.

→ 즉 어떤 브라우저를 지원하느냐에 따라 개발자의 선택. 구형 브라우저라면 안정적인 바벨이 좋고, 모던 브라우저라면 최신 번들링 툴을 사용하는것을 추천.

**여러 플러그인을 쉽게 설정할 수 있는 프리셋 제공**

플러그인을 일일이 설정해야한다는 단점을 보완하기 위해서 여러 플러그인을 묶어놓은 프리셋 기능을 제공한다.

- @babel/preset-env : 최신 자바스크립트(ES6+) 코드를 지정한 브라우저 환경에 맞춰 하위 버전으로 변환합니다.
- @babel/preset-react: 브라우저가 이해하지 못하는 **JSX** 문법을 자바스크립트 함수 호출 코드로 변환합니다.
  - react17에서 소개된 새로운 JSX변환인 runtime옵션이 추가됨
  - classic 런타임
    - JSX를 쓰려면 파일 상단에 반드시 `import React from 'react'`가 있어야 했습니다.
    - 이유: JSX가 `React.createElement`로 변하니까, `React`라는 변수가 코드에 존재해야 했음
  - automatic 런타임
    - 트랜스파일러(Babel 등)가 JSX를 변환할 때, 아예 자기들이 미리 준비한 특수한 함수(`_jsx` 등)를 **몰래 자동으로 import** 해서 변환해 줌
- @babel/preset-typescript: 코드에서 **타입 주석(Type Annotation)**들만 싹 제거해서 순수 자바스크립트로 만듭니다.
- @babel/preset-flow: 타입스크립트와 경쟁했던 'Flow'라는 타입 체크 도구를 위한 프리셋. 이 문법을 제거해주는 역할

**활발한 커뮤니티 지원**

바벨은 오픈소스로 시작해서 많은 개발자의 기여와 피드백을 통해 발전하고 있음.

### 바벨의 동작 방식

바벨은 추상구문트리(AST)를 기반으로 동작하며 자체적으로 변환 과정에 필요한 기능을 독립적인 패키지로 관리한다.

**추상구문트리**

추상 구문 트리는 소스코드를 트리 형태로 표현한 자료구조,

- 노드: 트리의 각 요소를 나타내며, 변수나 함수 선언문 등 코드의 구문 요소를 의미하는 기본 단위
- 자식 노드: 특정 노드의 하위 요소 . 함수 선언문의 경우 함수명이나 파라미터, 함수 블록의 내용 등을 자식 노드로 표현.
- 최상위 노드: 트리의 최상위 노드로, 전체프로그램이나 코드블록을 나타냄.

ESLint와 같은 린팅 도구도 이런 추상구문트리를 활용해서 작업을 수행한다.

**바벨이 코드를 변환하는 방식**

바벨이 코드를 변환하는 과정은 파싱, 변환, 출력 세 단계로 나뉘어 진행하며 각 단계마다 패키지로 분리해서 제공함

- 파싱: @babel/parser를 활용해서 최신 ECMAScript 부터 JSX, Flow, 타입스크립트 등 변환할 수 있다.
- 변환: 변환 단계에서 각 플러그인은 추상구문 트리를 탐색해서 변환이 필요한 노드를 찾아 변경한다.
  - 예를들어 const를 var로 변경하는 플러그인이 실행.
  - @babal/traverse 패키지가 추상구문 트리 노드를 깊이우선 방식으로 조작할 수 있는 기능을 제공한다.
- 출력: 변환단계에서 수정된 추상구문 트리를 다시 코드로 변환해서 최종적으로 출력한다. 이 단계에서 @babel/generator가 사용된다.

### 바벨 사용해보기

**바벨 구성파일**

- babel.config
- .babelrc
- pacakge.json의 babel 필드.

바벨 구성파일에서 사용할 수 있는 조요한 옵션들은

- preset, plugins, env, ignore, include/exclude, sorceMaps, compact …등이 있다.

**번들러와 함께 사용하기**

바벨을 단독적으로 사용하게되면

- 모듈시스템 변환문제 : 브라우저는 require(), export.module과 같문법을 지원하지 않음.
- 최적화 문제 : 바벨은 단독으로 코드분할 기능을 지원하지 않기 때문에 모든 코드를 하나의 파일로 번들링하게되면 초기 로드 시간이 길어질 수 있다.

와 같은 문제가 발생한다.

실제 프로젝트에서는 바벨만 쓰기보단 번들러와 함께 사용해서 이런 문제를 해결한다.

---

## 5-2. 폴리필을 도와주는 도구 core-js

트랜스파일만으로 해결되지 않는 기능들을 제공하기 위해 동일한 이름으로 낮은 ES문법만 사용가능한 구형 브라우저 환경에서도 작동하도록 **전역에 생성되는 메서드나 객체를** **폴리필**이라고 한다.

### core-js란 무엇인가?

자바스크립트 개발자이자 오픈소스 기여자인 데니스 푸슈카레프라는 사람에 의해 만들어진 자바스크립트 폴리필 라이브러리.

이전 ES5 기능부터 최신기능인 이터레이터, structuredClone 까지 포함할 정도로 최신 자바스크립트의 전반적인 기능의 폴리필을 지원한다.

대부분 개발자들이 직.간접적으로 이 core-js를 사용하고 있고 실제로 TOP 1000개의 웹사이트중에 54%이상, 상위 100개는 75%~80% 정도로 core-js를 사용하고 있다.

### 바벨과 core-js

core-js를 직접 설치하는거보다 바벨을 통해 개발자가 직접 어떤 폴리필이 필요한지 결정하지 않아도 되어 훨씬 편리함으로 바벨과 함께 사용되는걸 권장하고있다.

**@babel/preset-env에 core-js 설정하기**

![image.png](attachment:cdf5ce8b-776d-43fd-abeb-13fc5384afcb:image.png)

- targets.browser 필드에서 브라우저 환경을 지정해 필요한 폴리필만 포함되게 할 수 있다.
- useBuiltIns: 바벨이 폴리필을 어떻게 처리할 것인지 동작모드를 설정할 수 있는 옵션
  - false: 난 폴리필 따위 신경 안 써. 네가 알아서 해
    - 폴리필을 자동으로 주입하지 않습니다. 개발자가 직접 최상단에 `import "core-js"` 등을 적어야 하며, 이렇게 하면 브라우저 환경에 상관없이 **모든 폴리필이 포함되어 번들 용량이 매우 커짐.**
  - entry: 엔트리 파일에서 한번에 폴리필 모드를 추가하는 옵션
    - → 전역 파일(보통 `index.js`) 상단에 `import "core-js"`를 딱 한 번만 적어줍니다.
    - 그러면 바벨이 `browserslist`(타겟 브라우저)를 보고 **그 브라우저들에 필요한 폴리필들로 쫙 펼쳐서(치환해서) 넣어줍니다.** → 사용하지 않는 폴리필까지 포함될 수 있지만, 설정이 명확하고 안전합니다.
  - usage: 네가 코딩하는 걸 지켜보다가, 딱 필요한 것만 그때그때 가방에 쏙 넣어줄게
    - 바벨이 코드를 한 줄 한 줄 분석합니다. 만약 내 코드에 `[].includes()`가 있는데 타겟 브라우저가 이걸 지원 안 한다면? **그 파일 최상단에 딱 그 폴리필만 자동으로 `import` 해줍니다.**

**런타임에 core-js** **폴리필 로드하기**

core-js를 직접 임포트하거나 프리셋에 설정하는 방식은 어떤 상황에서는 바람직 하지 않을 수 있다고 함.

- 큰 번들크기, 전역 네임스페이스 오염

@babel/plugin-transform-runtime을 사용해서 런타임에 폴리필 코드를 로드할 수 있다.

이 플러그인을 사용하려면 @babel/preset-env에 설정한 폴리필 옵션을 제거해야함( 폴리필 처리방식이 충돌날 수 있기 때문)

![image.png](attachment:385a0e5d-c6f1-4581-a0a5-4d849fdf2075:image.png)

→ 오픈소스 라이브러리 개발에 필수인 옵션임.

→ 라이브러리를 깔았는데 만약 전역오염이 된다면? (window 객체를 직접 건들이기 때문에)

전역 오염 없이 폴리필 가능

```jsx
// 1. 전역 Promise를 건드리지 않고, 별도의 모니터(_Promise)를 빌려옵니다.
import _Promise from "@babel/runtime-corejs3/core-js-stable/promise";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";

// 2. 내가 쓴 'Promise'라는 단어를 빌려온 '_Promise'로 바꿉니다.
const myTask = _asyncToGenerator(function* () {
  return new _Promise((resolve) => resolve("완료!"));
});
```

---

## 5-3. 최선의 폴리필과 트랜스파일은 무엇일까?

### 지원 환경 명시하기

프로젝트가 목표로하는 브라우저를 명확히 하면 불필요한 폴리필과 트랜스파일링을 줄일 수 있어 번들 크기를 최소화 할 수 있다.

### **browserlist**

다양한 프런트엔드 도구들이 공통된 브라우저 및 Node.js 버전 설정을 공유할 수 있게 해주는 도구

한마디로 내 프로젝트가 **"어떤 브라우저까지 지원할 것인가?"**를 명시해놓은 **'공통 타겟 리스트'**.

**설정 방법**

Browserslist는 아주 쉬운 문장으로 작성할 수 있다. 보통 `package.json`이나 `.browserslistrc` 파일에 아래와 같이 명시

- **시장 점유율 기준**
  - `≥5%` : 전 세계 시장점유율이 5% 이상인 브라우저를 지원
  - `> 1%`: 전 세계 점유율이 1% 이상인 모든 브라우저 지원
- **최신버전 기준**
  - `last 2 versions`: 각 브라우저의 최신 2개 버전까지 지원
- **유지보수 상태**
  - `not dead`: 보안 업데이트가 끊긴 '죽은' 브라우저(IE 등)는 제외
- **정확한 버전 지정**
  - `ie 11`: 특정 브라우저(예: IE 11)를 콕 집어서 지원

내 프로젝트가 지원하는 브라우저 리스트 확인하기

```jsx
npx browserslist
```

**core-js-compat**

- core-js에서는 browserlist로 설정한 지원 범위에 알맞은 폴리필 코드만 추가할 수 있는 패키지인 core-js-compat를 제공한다.
- **core-js-compat**는 한마디로 **"어떤 브라우저가 어떤 최신 기능을 지원하는지"**에 대한 방대한 데이터를 담고 있는 **'매핑 사전'**입니다.

**@babel/preset-env의 targets 필드**

- 바벨이 코드를 트랜스파일할 때 지원 환경을 명시해서 필요한 바벨 플러그인만을 사용할 수 있게 하는 프리셋
- targets 필드를 ㅎ사용해 목표 환경 범위 내 ㅇ트랜스파일해야할 플러그인만 적용 가능
- 필드 작성 방법
  - 특정 브라우저 혹은 node버전, 복합 조건 사용, tagets이 없음.

**@babel/plugin-transform-runtime과 browserslist** 함께 사용하기

- 오픈소스 패키지를 만들 때 불필요한 헬퍼함수 코드를 줄이고 전역 오염이 없는 core-js를 사용할 때.

![image.png](attachment:b1586920-8b45-4a6b-9d04-e0ab1979ea18:image.png)

- 가장 최신버전인 core-js의 v3버전을 사용하겠다 라는 의미
- 이 설정을 하면 바벨이 내 코드의 `Promise`를 `@babel/runtime-corejs3/core-js-stable/promise` 같은 경로에서 가져오는 변수로 바꿔버립니다.

### 폴리필의 올바른 주입 방법

**폴리필 버전 제한 문제점**

- **@babel/preset-env (똑똑함):** `corejs: "3.20"`처럼 세부 버전까지 적으면 "아, 3.20 버전에 추가된 기능까지 다 챙겨줄게!"라고 알아들음
- **@babel/plugin-transform-runtime (융통성 없음):** 이미지 설정처럼 `"version": 3`이라고 적으면, 얘는 이걸 `3.0.0`으로만 해석

```jsx
arr.findLast();
```

이 코드가 구형 브라우저에서 실행되면 `findLast is not a function` 에러를 뿜으며 앱이 죽어버림

**올바른 폴리필 주입을 위한 플러그인 babel-plugin-polyfill-corejs3**

`@babel/plugin-transform-runtime`은 너무 멍청해서 최신 자바스크립트 기능을 놓치기 쉬우니, 더 똑똑한 `babel-plugin-polyfill-corejs3`로 갈아타라.

**적용하기**

- `@babel/plugin-transform-runtime`에서는 **`corejs` 옵션을 제거**합니다. (얘는 이제 헬퍼 함수 중복 제거만 담당하게 합니다.)
- `babel-plugin-polyfill-corejs3`를 설치하고 플러그인 목록에 추가합니다.
- 거기에 구체적인 `corejs` 버전(예: `3.30`)을 적어줍니다.

## 5.4 바벨과 core-js의 대안

babel과 core-js는 모든 프로젝트에서 항상 최선의 선택이 아닐 수 있다

### 타입스크립트 컴파일러

트랜스파일링은 바벨대신 타입스크립트 컴파일러를 사용할 수 있다.

- 타입스크립트 컴파일러는 정적 타입 검사 뿐만 아니라 트랜스파일링 까지 지원.
- tsconfig.json에 target 필드를 지정해서 사용 가능

**트랜스파일에 영향을 주는 옵션들**

- Module: 타입스크립트 컴파일러가 코드를 변환할 때 사용할 모듈 시스템을 결정하는 필드이다. →
  - 이 module 필드는 target 값에 따라 기본값이 달라진다.
  - 만약 ES3거나 ES5라면 CommonJS 모듈 시스템을 사용 →
  - 그 이상이면 ESModule을 사용하게끔 되어있음.
- ## lib: `lib`은 타입스크립트가 "이 환경에서는 이런 기능들이 기본적으로 존재해"라고 믿게 만드는 **타입 정의 파일(`d.ts`)의 묶음**
- sourceMap: 컴파일된 자바스크립트 파일에 소스맵을 생성할지 여부
  - 소스맵은 디버깅시 원본 타입스크립트 코드와 트랜스파일된 자바스크립트 코드간의 맵핑을 제공함.
- jsx:

**타입스크립트 런타임 라이브러리 tslib**

`@babel/plugin-transform-runtime`이 바벨에서 했던 역할과 비슷함.

왜 필요할까?

- 타입스크립트 코드를 자바스크립트로 변환할 때, 구형 환경 지원을 위해 `class` 상속이나 `async/await`, `...`(spread) 연산자 등을 구현하는 **보조 코드(Helper functions)**가 필요.
- **기본 동작:** `tslib`가 없으면, `tsc`는 이런 보조 코드가 필요한 **모든 파일마다** 해당 코드를 직접 복사해서 집어 넣음.
- **문제점:** 프로젝트에 파일이 100개 있고 모두 `async/await`를 쓴다면, 똑같은 보조 코드가 100번이나 중복되어 번들 용량이 불필요하게 커진다

![image.png](attachment:602058d7-4cd6-4f3f-9cb6-9bc2011c2bd3:image.png)

![image.png](attachment:0c8e74bb-05d3-44f1-853c-041f63cdf592:image.png)

이 문제를 해결하기 위해 tslib를 사용하게 되면

```jsx
npm install tslib --save
```

tsconfig.json에 `importHelper` 옵션을 추가해 true로 설정하면 타입스크립트 컴파일러가 헬퍼 함수들을 tslib라이브러리에 가져와 트랜스파일 한다.

![image.png](attachment:6d98f4ee-3565-4793-9aee-9b12eea26084:image.png)

**타입스크립트 컴파일러와 바벨 비교**

### SWC

바벨의 대안으로 부상하고 있는 또 다른 트랜스파일러인 SWC.

SWC는 러스트기반으로 개발된 고성능 트랜스파일러로, 바벨과 비교해서 상당히 빠른 속도를 자랑함.

### swc의 특징

- 바벨과의 호환성
  - SWC는 바벨과 굉장히 유사한 설정방식을 지원하며, 바벨의 많은 플러그인을 대체할 수 있는 기능을 제공한다.
  - 이를 통해 기존 바벨 설정을 쉽게 SWC설정으로 옮길 수 있음
  - @babel/cli → @swc/cli, @babel/core → @swc/core
- 트리셰이킹
  - SWC는 사용되지 않는 코드를 제거해서 최종 번들 크기를 줄이는 트리셰이킹을 지원함.
- 타입스크립트와 강력한 통합
  - SWC는 타입스크립트를 완벽하게 지원 → 타입 검사없이 빠르게 트랜스파일링 할 수 있음. (바벨은 웹팩이나 롤업과 같은 번들러에 의존)
- 공식 스키마 제공: SWC는 구성파일 (.swcrc) 작성을 돕는 JSON 스키마를 제공
  - 이를 통해 IDE에서 자동완성, 구성파일의 유효성 검사 및 정적 분석이 가능

### SWC로 트랜스파일링 하기

1. 설치하기

```jsx
npm i @swc/cli @swc/core --save-dev
npm i --save core-js
```

1. `.swcrc` 파일을 설정하기

<aside>
💡

Next.js는 버전 12부터 **'Next.js Compiler'**라는 이름으로 SWC를 내장했음.
덕분에 우리가 복잡하게 설정 파일을 만질 필요가 없게 설계되었음

</aside>

### SWC와 바벨, 타입스크립트 컴파일러 비교

- 바벨의 플러그인 시스템은 매우 광범위한 기능을 제공하는 반면 SWC는 아직 이 부분에서는 제한적임.
- SWC는 플러그인 생태계가 있으나 rust로 작성해야하는 진입장벽이 있다.
- 자바스크립트 생태계는 오랜 기간 바벨을 중심으로 발전해왔기 때문에 일부 도구나 프레임워크에서는 SWC와 완벽이 호환되지 않을 수 있다.
  - 실제로 MobX와 같은 라이브러리가 지원하는 데코레이터를 사용하는 경우 SWC에서는 이기능이 완벽하게 호환되지 않는 경우가 있었음.

<aside>
💡

실제로 zod4 버전을 쓰고 있고 tsconfig.json의 타겟이 ES5였음 → swc로 컴파일을 했을 때 zod의 클래스 내부의 this 바인딩이 깨져서 프로덕션 환경에서 런타임 에러 발생.

</aside>

책에있는 비교포

![image.png](attachment:ca319627-8ef2-401d-807f-ddad84c712fb:image.png)

제미나이가 정리해준 비교 표

| **구분**            | **TypeScript Compiler (tsc)** | **Babel**                          | **SWC**                            |
| ------------------- | ----------------------------- | ---------------------------------- | ---------------------------------- |
| **핵심 역할**       | **타입 검사** + JS 변환       | **최신 문법 변환** (Polyfill 강점) | **초고속 변환** 및 컴파일          |
| **언어 (Base)**     | TypeScript (JavaScript)       | JavaScript                         | **Rust**                           |
| **속도**            | 보통                          | 느림                               | **매우 빠름** (Babel 대비 20~70배) |
| **타입 검사**       | **지원함**                    | 지원 안 함 (주석만 제거)           | 지원 안 함 (주석만 제거)           |
| **폴리필 지원**     | 약함 (target 위주)            | **매우 강력함** (preset-env)       | 강력함 (swc/polyfill)              |
| **커스텀 플러그인** | 매우 어려움                   | 매우 쉬움 (방대한 생태계)          | 보통 (Rust 학습 필요)              |

### es-shipms
