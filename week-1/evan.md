# 제1장 유의적 버전

### npm은 단순히 "설치 도구"를 넘어 크게 세 가지 독립적인 부분으로 구성됩니다.

- **웹사이트 (Website):** 패키지를 검색하고, 프로필을 설정하며, 오픈소스 생태계를 탐색하는 공간입니다.
- **명령줄 인터페이스 (CLI):** 개발자가 터미널에서 패키지를 설치, 업데이트, 관리하기 위해 실행하는 도구입니다.
- **레지스트리 (Registry):** 전 세계 자바스크립트 패키지와 그에 대한 메타데이터가 저장되어 있는 거대한 데이터베이스입니다.

### npm 이름의 유래: `pkgmakeinst`에서 `npm`까지

많은 개발자가 오해하는 부분이지만, npm은 처음부터 Node.js만을 위해 설계된 도구라기보다 **아이작 슐루터가 사용하던 기존 도구의 진화형**에 가깝습니다.

- **전신 (Ancestor):** 아이작이 만들었던 `pm`이라는 Bash 유틸리티가 있었습니다.
- **어원 (Origin):** 이 `pm`은 **`pkgmakeinst`**(Package Make Install)의 약자였습니다. 즉, 패키지를 만들고 설치하는 일련의 과정을 자동화하는 쉘 스크립트였던 셈이죠.
- **진화 (Evolution):** 이를 Node.js 환경에 맞게 이식하면서 `npm`이라는 이름이 붙었지만, 개발자는 이를 특정 문장의 약자로 고정하지 않았습니다.

https://github.com/npm/cli?tab=readme-ov-file#faq-on-branding - npm 공식문서에서도 이 점을 바라고 있다.

> 💡 재밌는 사실: npm 공식 홈페이지나 문서의 구석구석을 보면, 매번 페이지를 새로고침할 때마다 "Node People Mouthwash", "Never Play Monopoly" 같이 npm을 활용한 농담조의 무작위 약어(Backronym)가 표시되곤 합니다. 이는 npm이 특정 단어의 약자가 아니라는 점을 위트 있게 표현하는 방식입니다.

### npm의 아버지: 아이작 Z. 슐루터 (Isaac Z. Schlueter)

아이작 슐루터는 야후(Yahoo!) 재직 시절부터 코드를 패키징하는 작업에 능숙했습니다. 그는 Node.js의 가능성을 보고, 파이썬의 `easy_install`이나 루비의 `gems`와 같은 편리한 패키지 관리 시스템을 자바스크립트 세계에도 구현하고자 했습니다.

![Schlueter.png](https://github.com/user-attachments/assets/27a9d1d8-779f-4a42-95b0-3ed714c88cd5)

https://increment.com/development/interview-with-isaac-z-schlueter-ceo-of-npm/

### npm 발전 연대기

- **2009년 9월:** npm의 첫 버전 등장.
- **2011년:** npm v1.0.0 출시. Node.js의 기본 패키지 관리자로 포함되며 폭발적 성장.
- **2013년:** 급격한 트래픽 증가로 인한 서버 불안정 해결을 위해 **npm, Inc.** 설립.
- **2020년:** GitHub(Microsoft)에 인수되어 서비스 안정성과 공공성 강화.

### 관리 방식의 패러다임 변화: CDN에서 npm으로

과거에는 라이브러리를 사용하기 위해 직접 파일을 다운로드하거나 CDN 링크를 걸어야 했습니다. 하지만 npm의 등장으로 개발 방식이 완전히 바뀌었습니다.

| **비교 항목** | **과거 (CDN/Direct Download)**   | **현재 (npm/Package Manager)**              |
| ------------- | -------------------------------- | ------------------------------------------- |
| **방식**      | `<script src="...">` 태그 삽입   | `npm install <package>`                     |
| **의존성**    | 수동으로 순서에 맞춰 로드해야 함 | `package.json`에서 자동으로 관리            |
| **버전 관리** | URL 주소를 직접 수정해야 함      | 시멘틱 버저닝($SemVer$)으로 유연한 업데이트 |
| **빌드 과정** | 브라우저가 매번 파일을 다운로드  | Webpack, Vite 등을 통해 최적화된 번들 생성  |

### 마이크로소프트의 인수

npm은 2020년 4월, 개발자들의 최대 커뮤니티인 GitHub(결과적으로 Microsoft)에 인수되었습니다. 이는 npm 레지스트리의 영속성을 보장하고, 세계 최대의 코드 저장소와 패키지 관리자가 하나로 통합되어 시너지를 내는 계기가 되었습니다.

## 1.1.2 npm 의 주요 기능

### 1. 패키지 설치 및 의존성 관리

프로젝트에 필요한 외부 라이브러리를 가져오고 관리하는 가장 핵심적인 기능입니다.

- **의존성 체계화:** `package.json`의 `dependencies`(운영용)와 `devDependencies`(개발용)에 선언된 패키지를 `node_modules` 폴더에 자동으로 설치합니다.
- **유지보수 도구:** **업데이트:** 최신 버전으로의 안전한 패키지 업데이트 지원.
  - **보안 점검:** `npm audit`을 통해 보안 취약점이 발견된 패키지를 식별하고 수정 권고안을 제시합니다.
  - **무결성 보장:** `package-lock.json`을 통해 팀원 모두가 동일한 버전의 환경에서 작업할 수 있게 합니다.

### 2. 패키지 배포 및 공유 (npm Registry)

전 세계 개발자들이 코드를 공유하는 세계 최대 규모의 **오픈소스 레지스트리** 역할을 합니다.

- **오픈 생태계:** 누구나 자신이 만든 패키지를 레지스트리에 업로드(Publish)하고 전 세계에 공유할 수 있습니다.
- **Private 패키지:** 유료 플랜을 통해 외부에는 공개되지 않는 기업/팀 내부용 비공개 패키지 관리도 가능합니다.
- react: https://registry.npmjs.org/react

### 3. 강력한 스크립트 실행기 (Scripts)

단순 명령어를 넘어, 복잡한 워크플로우를 CLI 명령 하나로 단순화합니다.

- **명령어 단축:** `package.json`의 `scripts` 필드를 활용해 빌드, 테스트, 배포 등 길고 복잡한 명령어를 `npm run <이름>` 형태로 실행합니다.
- **자동 PATH 등록:** 별도의 환경 변수 설정 없이도 `node_modules/.bin`에 있는 실행 파일(예: `eslint`, `prettier`)을 프로젝트 내에서 즉시 실행할 수 있게 도와줍니다.

### 4. 정보 허브: npmjs.com

패키지의 '백과사전'과 같은 웹사이트를 제공하여 개발자가 올바른 선택을 하도록 돕습니다.

- **패키지 인사이트:** 코드 개요, 의존 관계, 해당 패키지를 사용하는 다른 프로젝트 목록 등을 확인할 수 있습니다.
- **신뢰성 지표:** 주간 다운로드 수(Weekly Downloads), 최신 버전 정보, 마지막 업데이트 시점 등을 통해 패키지의 활성화 정도를 파악할 수 있습니다.
- **코드 브라우징:** 레지스트리에 업로드된 실제 소스 코드를 웹에서 바로 탐색할 수 있는 기능을 제공합니다.

### 1.1.3 npm과 관련된 유용한 사이트

npm 레지스트리 자체 기능 외에도, 패키지 선정과 최적화를 돕는 강력한 도구들이 존재합니다.

### 1. 번들포비아 (Bundlephobia)( https://bundlephobia.com/ )

- **용도:** 패키지가 내 프로젝트의 번들 크기에 미치는 영향을 분석합니다.
- **주요 기능:**
  - 패키지의 **Minified + Gzipped 크기** 및 다운로드 예상 시간 제공.
  - 해당 패키지가 **Tree-shaking**을 지원하는지 여부 확인.
  - 버전별 크기 변화 추이를 그래프로 확인하여 업데이트 여부 결정에 도움.
- **활용:** 성능 최적화가 중요한 프론트엔드 작업 시, 무거운 라이브러리 도입을 방지하기 위해 사용합니다.

### 2. npm 트렌드 (npm Trends) (https://npmtrends.com/)

- **용도:** 여러 패키지의 인기도와 유지보수 상태를 비교 분석합니다.
- **주요 기능:**
  - 최대 10개 패키지의 **주간 다운로드 횟수**를 시계열 그래프로 비교.
  - GitHub Stars, 이슈 개수, 마지막 업데이트 날짜 등 **건강도 지표** 제공.
- **활용:** "Moment.js를 쓸까, Day.js를 쓸까?"처럼 기술 스택 선정의 근거가 필요할 때 객관적인 지표로 활용합니다.

### 3. unpkg (https://unpkg.com/)

- **용도:** npm 패키지 내부의 파일을 브라우저에서 즉시 확인하거나 CDN으로 사용합니다.
- **주요 기능:**
  - `unpkg.com/:package/` 처럼 주소 끝에 `/`를 붙여 **전체 파일 목록(Directory Listing)** 확인.
  - 별도의 설치 없이 특정 파일의 코드를 웹에서 바로 열람 가능.
- **참고 (React 19 변화):** > **💡 UMD 빌드 제거:** React 19부터는 더 이상 UMD 빌드를 제공하지 않습니다. 이는 현대 브라우저가 **ES Modules(ESM)**를 네이티브로 지원하기 때문이며, 이제는 `<script type="module">`을 통해 ESM 기반 CDN(예: `esm.sh`)을 사용하는 것이 권장됩니다.

### 4. Snyk (Vulnerability Database) ( https://security.snyk.io/vuln/npm )

- **용도:** 전 세계 오픈소스 패키지의 보안 취약점을 실시간으로 확인합니다.
- **주요 기능:**
  - 취약점의 위험도를 **Low, Medium, High, Critical** 단계로 구분하여 리포트.
  - 영향을 받는 버전과 해결 방법(Fix) 정보 제공.
- **활용:** 보안이 중요한 엔터프라이즈 환경에서 검증되지 않은 외부 라이브러리 도입을 필터링할 때 필수적입니다.

## 1.2 유의적 버전

> 소프트웨어의 버전을 어떻게 정의하고, 어떻게 올리고 관리하는지에 대한 규약

**유의적 버전의 의의**

- 개발자→사용자: 해당 소프트웨어의 예상되는 변경점을 사용자에게 손쉽게 알려줄 수 있음
- 사용자→개발자: 개발자가 유의적 버전 체계를 지켰다는 가정하에 해당 소프트웨어에 유연하게 의존할 수 있는 시스템을 만들 수 있음

### **1.2.1. 유의적 버전의 등장 배경과 정의**

### 패키지 업데이트의 딜레마와 보수적 접근

매일 수천 개의 패키지가 릴리스되는 상황에서 모든 변화를 추적하는 것은 불가능합니다. 특히 오픈소스는 관리자의 성향에 따라 예고 없이 큰 변화가 생길 수 있어 주의가 필요합니다.

### 유의적 버전

([https://semver.org/lang/ko/#유의적-버전-명세-semver](https://semver.org/lang/ko/#%EC%9C%A0%EC%9D%98%EC%A0%81-%EB%B2%84%EC%A0%84-%EB%AA%85%EC%84%B8-semver))

> **요약**
>
> 버전을 **주.부.수(Major.Minor.Patch)** 숫자로 하고:
>
> 1. 기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”을 올리고,
> 2. 기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”을 올리고,
> 3. 기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”을 올린다.
>
> 주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.

### 유의적 버전의 버전의 구체적인 명세

### 1. 공개 API의 선언

소프트웨어는 반드시 **공개 API**를 선언해야 합니다. 이는 코드(코드상의 주석 등)나 문서로 엄격히 명시해야 하며, 누구든 이해할 수 있도록 정확해야 합니다.

### 2. 버전 번호의 표준 형식

버전 번호는 반드시 **‘X.Y.Z’** 형태여야 합니다. X, Y, Z는 각각 음이 아닌 정수(자연수)이며, `01`처럼 **앞에 0이 붙어서는 안 됩니다.** 또한 주, 부, 수 버전 번호는 이전보다 반드시 증가해야 합니다.

### 3. 배포 후 불변성

특정 버전의 패키지를 배포하고 나면, **해당 버전의 내용은 절대 변경할 수 없습니다.** 변경 사항이 있다면 반드시 새로운 버전 번호로 다시 배포해야 합니다.

### 4. 주 버전 0의 특수성 (0.Y.Z)

주 버전이 **0**인 단계는 초기 개발을 위한 버전입니다. 이 단계에서는 API를 마음대로 바꿀 수 있으며, **안정판으로 보지 않습니다.**

### 5. 정식판의 시작 (1.0.0)

**1.0.0 버전**은 공개 API가 정의된 시점입니다. 이후의 모든 버전 번호는 이 시점에 배포된 API의 변경 정도에 따라 결정됩니다.

### 6. 수 버전(Patch) 증가 규칙

**수 버전 Z**는 이전 버전과 **호환되는 버그 수정**인 경우에만 올립니다. 버그 수정은 잘못된 내부 기능을 고치는 행위로 정의합니다.

### 7. 부 버전(Minor) 증가 규칙

**기존과 호환되는 새로운 기능이 추가**될 때 부 버전을 올립니다.

- 특정 API를 제거 예정(Deprecated)으로 표시할 때도 올립니다.
- 내부 코드에 대폭적인 개선이 있을 때도 올릴 수 있습니다.
- 부 버전이 올라가면 **수 버전은 반드시 0으로 초기화**합니다.

### 8. 주 버전(Major) 증가 규칙

기존과 호환되지 않는 API 변화(Breaking Changes)가 있을 때 반드시 주 버전을 올립니다.

- 이 버전에는 부 버전이나 수 버전 급의 변화를 포함할 수 있습니다.
- 주 버전이 올라가면 **부 버전과 수 버전은 반드시 0으로 초기화**합니다.

### 9. 정식 배포 전(Pre-release) 표기

수 버전 뒤에 붙임표(`-`)와 마침표로 구분된 식별자를 더해 표기합니다(예: `1.0.0-rc.1`).

- 정식 배포 전 버전은 관련 일반 버전보다 **우선순위가 낮습니다.**
- 불안정한 상태이며, 호환성 요구사항이 충족되지 않을 수 있음을 알립니다.

### 10. 빌드 메타데이터(Build Metadata) 표기

버전 끝에 **더하기(`+`)** 기호를 붙여 빌드 정보를 추가할 수 있습니다(예: `1.0.0+20260111`).

- 식별자는 아스키 문자와 숫자, 붙임표로만 구성됩니다.
- **우선순위 판단 시 반드시 무시**됩니다. 즉, 빌드 메타데이터만 다른 두 버전의 순위는 같습니다.

### 11. 우선순위(Precedence) 결정 원칙

버전 정렬 시 비교하는 기준입니다.

- **주 > 부 > 수** 버전 순서대로 비교합니다.
- 배포 전 버전(Pre-release)은 숫자는 크기대로, 문자는 **아스키(ASCII) 정렬 순**으로 비교합니다.
- 빌드 메타데이터는 계산에 영향을 주지 않습니다.

- rc는 무슨 뜻인가요?

  rc는 ‘release candidate’의 약자로 정식 버전이 되기 직전의 버전을 의미한다. rc 식별자가 추가됐다는 것은 정식 버전 출시가 임박했다는 것을 의미한다.

- 초기 버전은 0.0.0 0.0.1 0.1.0 중 무엇을 사용해야 하나요?
  유의적 버전의 명세상 초기 버전은 0.1.0이지만 프로젝트의 상황이나 필요에 따라 원하는 버전에 맞춰서 사용하면 된다.

### 1.2.3 유의적 버전의 문법

```sql
^(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-(0|[1-9A-Za-z-][0-9A-Za-z-]*)(\.[0-9A-Za-z-]+)*)?(\+[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$
```

- 하지만 복잡한 정규표현식을 사용하는것보다 semver을 사용하는것이 일반적

### **1.3 유의적 버전과 npm 생태계의 명과 암**

npm은 거대한 생태계인 만큼, 작은 패키지 하나가 전체 생태계를 마비시키거나 보안 위협을 초래할 수 있는 취약점을 가지고 있습니다.

**1.3.1 left-pad: 수천만 패키지에서 의존하는 유틸 패키지가 사라지면 어떻게 될까?**

- **사건:** 단 11줄짜리 문자열 유틸 패키지인 `left-pad`의 개발자가 자신의 패키지들을 모두 삭제(Unpublish)함.
- **영향:** `left-pad` → `line-numbers` → `babel`로 이어지는 의존성 때문에 전 세계 수많은 프로젝트의 빌드가 중단됨.
- **후속 조치:** npm은 이례적으로 삭제된 패키지를 강제 복구했으며, 이후 "다른 패키지가 의존하고 있는 패키지는 삭제할 수 없다"는 새로운 정책을 수립했습니다.

https://github.com/left-pad/left-pad/issues/4#issuecomment-200051244

**1.3.2 everything: 모든 자바스크립트 패키지를 의존성으로 가진다면?**

- **사건:** npm의 **모든 패키지**를 의존성으로 가지는 `everything` 패키지가 등장.
- **영향:** 앞선 `left-pad` 정책(의존 중인 패키지 삭제 불가) 때문에, npm 상의 거의 모든 패키지가 삭제 불가능한 상태에 빠짐.
- **해결:** npm 팀이 개입하여 해당 패키지를 삭제하고 나서야 혼란이 마무리되었습니다

**1.3.3 is-promise: 잘못된 부 버전 업데이트가 만들어낸 사태**

- **사건:** `is-promise`가 부 버전 업데이트 중 잘못된 문법(ESM 관련)을 포함한 버전을 배포.
- **영향:** `create-react-app` 등 이를 직/간접적으로 사용하는 수많은 도구가 즉시 먹통이 됨.
- **교훈:** 개발자가 유의적 버전을 준수하려 노력해도, 단 한 번의 실수가 거대한 파생 효과를 낼 수 있음을 보여준 사례입니다.

- ^(Caret)는 무엇인가요?
  **의미:** 지정된 버전을 기준으로 하위 호환성이 보지되는 범위(부 버전)까지 업데이트를 허용합니다.
  **동작 방식:**
  • `^1.2.3`: $1.2.3 < version < 2.0.0 (주 버전 1 내에서 최신 버전 유지)
  • `^0.2.3`: $0.2.3 < version < 0.3.0 (주 버전이 0일 때는 부 버전도 파괴적 변경이 가능하므로 수 버전만 업데이트)
  **장점:** 버그 수정이나 새로운 기능을 자동으로 받아볼 수 있어 편리합니다.
  **단점:** 위 사건들처럼 **자동으로 업데이트된 버전**에 버그나 악성 코드가 포함되어 있을 경우, 나도 모르게 문제가 발생할 수 있습니다.

**1.3.4 color.js와 faker.js: 섣부른 부, 수 버전 업데이트는 독이 될 수도 있다.**

- **사건:** 유명 패키지 관리자인 마라크(Marak)가 기업들의 무분별한 오픈소스 무임승차에 항의하며 의도적으로 무한 루프 코드를 심어 배포.
- **영향:** AWS CDK 등 이를 사용하던 수많은 엔터프라이즈 도구에서 'Zalgo' 텍스트가 출력되는 등 장애 발생.
- **시사점:** 오픈소스의 지속 가능성과 관리자의 권리에 대한 논쟁을 불러일으켰습니다.

[https://tech.pxd.co.kr/post/faker-js와-colors-js-사태를-통해-살펴보는-오픈소스의-양면성-226](https://tech.pxd.co.kr/post/faker-js%EC%99%80-colors-js-%EC%82%AC%ED%83%9C%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%8A%94-%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4%EC%9D%98-%EC%96%91%EB%A9%B4%EC%84%B1-226)

**1.3.5: event-stream 사건: 오픈소스는 얼마나 안전한가?**

- **사건:** 공격자가 `event-stream` 관리자에게 접근하여 권한을 넘겨받은 뒤, 비트코인을 탈취하는 악성 코드가 담긴 `flatmap-stream`을 의존성에 추가.
- **수법:** 사용자들이 보통 `^`나 `~`를 사용해 패키지를 설치한다는 점을 악용하여, 수 버전 업데이트를 통해 자연스럽게 악성 코드가 전파되도록 유도함.

https://blog.ull.im/engineering/2018/11/30/event-stream-issue.html

- ~(Tilde)의 의미와 동작 방식
  `~`는 지정된 버전에서 **수 버전(Patch)의 업데이트만 허용**하겠다는 의미입니다. 즉, "버그 수정은 받겠지만, 새로운 기능 추가(Minor)는 거절하겠다"는 의사표시입니다.

### **1.3.6 유의적 버전과 npm을 사용할 때 주의할 점**

패키지 매니저는 편리하지만, 전적으로 신뢰하기에는 리스크가 존재합니다. 안정적인 프로젝트 운영을 위해 다음의 수칙을 권장합니다.

### 1. 유의적 버전은 ‘약속’일 뿐 ‘강제’가 아니다

- **리스크:** 메인테이너의 실수나 고의로 인해 부 버전(`Minor`)에서 파괴적 변경이 일어날 수 있습니다.
- **대응:** 새로운 패키지 설치 시 반드시 **릴리스 노트**나 **CHANGELOG.md**를 확인하세요.
  - 극도로 안정성이 중요한 프로젝트라면 `^`, `~`를 제거하고 버전을 고정(Pinning)하여 사용하는 것도 전략입니다.

### 2. 패키지 설치 전 '3단계 검증'

무분별한 설치는 의존성 지옥을 만듭니다. 설치 전 스스로 세 가지 질문을 던져보세요.

1. **자체 구현이 가능한가?**: `left-pad` 사례처럼 단 몇 줄의 코드로 구현 가능한 기능을 위해 외부 의존성을 추가하고 있지는 않나요?
2. **검증된 패키지인가?**: 다운로드 수, GitHub Star, 마지막 업데이트 일자를 통해 생태계에서 충분히 검증되었는지 확인하세요.
3. **의존성이 깨끗한가?**: 해당 패키지가 설치될 때 같이 따라오는 `dependencies`가 너무 방대하거나 위험해 보이지 않는지 `package.json`을 훑어보세요.

### 3. 락 파일(lock file) 관리 및 `npm ci` 활용

`package-lock.json`은 프로젝트의 **설계도**와 같습니다.

- **변경 주의:** 코드 리뷰 시 `lock` 파일의 변경 내역이 너무 크다면, 원치 않는 패키지 업데이트가 포함되지 않았는지 의심해야 합니다.
- **`npm ci` 권장:** CI/CD 환경이나 팀원 간 환경 동기화 시에는 `npm install` 대신 `npm ci`를 사용하세요.
  - `npm install`: `package.json`을 기준으로 `lock` 파일을 수정할 수 있음.
  - `npm ci`: `lock` 파일이 없거나 `package.json`과 일치하지 않으면 설치를 중단하여 **버전 변동을 원천 차단**함.

### 4. 지속적인 보안 모니터링

보안은 '설치 시점'에만 중요한 것이 아니라 '사용 중'에도 계속 관리되어야 합니다.

- **Dependabot:** GitHub에서 제공하는 도구로, 의존성 내 취약점이 발견되면 자동으로 Pull Request를 생성해 줍니다.
- **Snyk:** 더 정밀한 보안 취약점 분석과 실시간 알림을 제공합니다.
- **npm audit:** 주기적으로 터미널에서 실행하여 현재 프로젝트의 취약점 상태를 점검하세요.
