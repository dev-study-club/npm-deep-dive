# Week 1: npm과 유의적 버전

> NPM과 패키지 관리의 핵심 개념 정리


## 목차

1. [유의적 버전 (Semantic Versioning)](#1-유의적-버전-semantic-versioning)
2. [NPM은 무엇인가](#2-npm은-무엇인가)
3. [CDN 방식의 구조적 문제](#3-cdn-방식의-구조적-문제)
4. [NPM + 빌드 방식이 해결하는 것](#4-npm--빌드-방식이-해결하는-것)
5. [릴리스 단계와 버전 종류](#5-릴리스-단계와-버전-종류)


## 1. 유의적 버전 (Semantic Versioning)

JS 라이브러리 대부분은 **유의적 버전(SemVer)** 규칙을 따른다.

```
MAJOR.MINOR.PATCH
  │     │     └── 버그 수정
  │     └── 기능 추가 (하위 호환 유지)
  └── 하위 호환성이 깨지는 변경 (Breaking Change)
```

| 버전 | 설명 | 예시 |
|------|------|------|
| **MAJOR** | 하위 호환성이 깨지는 변경 | `1.0.0` → `2.0.0` |
| **MINOR** | 기능 추가 (하위 호환 유지) | `1.0.0` → `1.1.0` |
| **PATCH** | 버그 수정 | `1.0.0` → `1.0.1` |

**공식 문서**: https://semver.org/


## 2. NPM은 무엇인가

보통 npm을 **Node Package Manager**의 약자로 알고 있지만, 실제로 npm은 **약자가 아닌 고유 프로젝트 이름**이다.

### npm의 역사

```
pkgmakeinst → pm (bash 유틸리티 모음) → npm
```

- **pm**: 다양한 bash 유틸리티 모음 (**pkgmakeinst**의 약자)
- **npm**: pm을 계승해 발전한 프로젝트

즉, npm 자체는 하나의 고유 명사이며, 굳이 의미를 붙이자면 **"node pm"** 또는 **"node pkgmakeinst 계열 프로젝트"**가 더 정확하다.

**참고**: [npm CEO 인터뷰](https://increment.com/development/interview-with-isaac-z-schlueter-ceo-of-npm/)

## 3. npm 이전에 자주 쓰이는 CDN 방식의 구조적 문제

신입 시절 레거시 프로젝트에서 종종 발견하게되는 jQuery CDN 로딩 방식이 대표적인 예로 떠올랐다.  
편리해 보이지만, 운영 관점에서는 여러 **근본적인 문제**가 존재한다.

---

### 3-1. 보안 문제

#### 공급망 공격 (Supply Chain Attack)

CDN 제공 업체가 해킹되면, 해당 CDN을 사용하는 **모든 사이트가 동시에 공격 대상**이 된다.

#### 대표 사례

| 사건 | 연도 | 내용 | 교훈 |
|------|------|------|------|
| **event-stream** | 2018 | 유지보수 권한 이관 후 악성 코드 삽입, 특정 암호화폐 지갑 타겟 | 신뢰된 의존성 하나가 전체 생태계를 위험에 빠뜨림 |
| **UA-Parser-JS** | 2021 | npm 계정 탈취, 정상 버전 번호로 악성 코드 배포 | "버전이 올라갔으니 안전하다"는 가정 붕괴 |
| **Polyfill.io** | 2024 | CDN 운영 주체 변경 후 악성 코드 삽입, 정부·대기업 다수 영향 | "유명한 CDN은 안전하다"는 믿음 붕괴 |

**참고 링크**
- [event-stream 사건](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident)
- [Polyfill.io 사건](https://news.hada.io/topic?id=15522)

---

#### SRI (Subresource Integrity)

브라우저가 외부 리소스를 로드할 때 **파일 해시를 검증**하는 보안 메커니즘

```html
<script
  src="https://cdn.example.com/library.js"
  integrity="sha384-abc123..."
  crossorigin="anonymous">
</script>
```

**SRI가 막을 수 있는 것**
- CDN 서버 해킹으로 파일이 변조된 경우
- 네트워크 중간자 공격(MITM)

**SRI의 한계**
- 악성 코드가 정상 버전 번호/해시로 릴리스된 경우는 막지 못함

---

### 3-2. 외부 통제 불가

| 문제 | 영향 |
|------|------|
| CDN 장애 | 서비스 중단 |
| 국가 단위 차단 | 특정 지역 접근 불가 |
| DNS / 도메인 이슈 | 리소스 로드 실패 |

> **핵심**: 내 코드와 무관한 이유로 서비스가 중단될 수 있다

---

### 3-3. 사용자 추적 이슈

라이브러리 다운로드 시 외부 CDN 제공자에게 전달되는 정보
- IP 주소
- Referer 헤더

→ **개인정보·보안 정책 리스크**

---

### 3-4. 버전 관리 문제

CDN에서 흔히 사용하는 **범위 버전 URL**

```
/react@latest    ← 항상 최신 버전
/react@16        ← 16.x.x 중 최신
```

> **치명적 문제**: 라이브러리 제작자가 마이너 업데이트에서 버그를 추가하거나 호환성을 깨면,  
> **나는 아무것도 하지 않았는데 어느 날 갑자기 사이트가 깨진다.**

---

### 3-5. 의존성 지옥 & 중복 다운로드

CDN 방식은 **의존성 그래프를 관리하지 않는다**.

```
A 라이브러리 → lodash 사용
B 라이브러리 → lodash 사용
         ↓
사용자는 lodash를 두 번 다운로드
```

**결과**
- 불필요한 네트워크 비용
- 로딩 속도 저하
- 전역 충돌 가능성 증가

---

### 3-6. 트리 쉐이킹 불가

**Tree Shaking** = 사용하지 않는 코드 제거

| 방식 | 동작 | 결과 |
|------|------|------|
| **CDN** | 라이브러리 전체 다운로드 | 함수 1개만 사용해도 100% 로드 |
| **NPM + 빌드** | 실제 import한 코드만 남김 | 70KB → 2KB 가능 |

---

### 최근 이슈

- [NPM 관련 이슈](https://news.hada.io/topic?id=24053)
- [DuckDB](https://news.hada.io/topic?id=22990)
- [2025 Shai-Hulud](https://news.hada.io/topic?id=24597)


## 4. NPM + 빌드 방식이 해결하는 것

### 4-1. 보안: 통제권의 이동

| 방식 | 신뢰 대상 | 통제권 |
|------|----------|--------|
| CDN | 외부 서버 | 없음 |
| NPM + 빌드 | 내가 다운로드 → 검증 → 배포 | 있음 |

→ **외부 CDN 사고가 서비스에 직접 영향 없음**

---

### 4-2. 버전 고정: Lock File

`package-lock.json`이 고정하는 것

```json
{
  "name": "my-project",
  "dependencies": {
    "lodash": {
      "version": "4.17.21",        // 정확한 버전
      "integrity": "sha512-..."    // 정확한 해시
    }
  }
}
```

→ **언제, 누가 설치해도 동일한 코드**

---

### 4-3. 의존성 중복 제거

- 패키지 매니저가 중복 감지
- 하나만 설치해 공유

→ **용량·충돌·불안정 감소**


### 라이브러리 비교 관련 참고 사이트(책에 있는 것 외에)

- [npm-compare.com](https://npm-compare.com/) - 패키지 비교 도구


## 5. 릴리스 단계와 버전 종류

### 버전 흐름도

```
                    ┌── experimental (실험적, 폐기 가능)
                    ↓
nightly → canary → beta → RC → stable
   │         │       │     │      │
   │         │       │     │      └── 정식 릴리스
   │         │       │     └── Release Candidate (정식 직전)
   │         │       └── 베타 테스트
   │         └── 조기 배포 (실환경 테스트)
   └── 매일 빌드
```


### 5-1. Canary 버전

**정식 릴리스 전, 실환경에 가장 가까운 조기 배포 버전**

| 특징 | 설명 |
|------|------|
| 목표 | 정식 릴리스 |
| 상태 | 거의 완성 |
| 목적 | 회귀·성능 테스트 |

---

### 5-2. Experimental 버전

**정식 채택 여부조차 미정인 실험 단계**

| 특징 | 설명 |
|------|------|
| 안정성 | 언제든 폐기 가능 |
| API | 불안정 |
| 목적 | 기술 검증 |

---

### 5-3. RC (Release Candidate)

**정식 릴리스 직전 단계** - 더 큰 문제 없으면 그대로 stable

```
1.2.0-rc.1 → 1.2.0-rc.2 → 1.2.0 (정식)
```

---

### 잡담

비슷한 네이밍 컨벤션을 가진 설정 파일들이 떠올랐다.

| 파일 | 의미 |
|------|------|
| `.zshrc` | **r**un **c**ommands |
| `.eslintrc` | **r**untime **c**onfiguration |
